## The Physics of Lens-Flares
- def: A lens-flare is a composition of several behaviors based on the way light bounces inside the lens of a camera. While initially seen as defects -> 多次折射/反射后的与原来光源方向相反的光线反向延申至感光面产生的虚影？？？![20250414143108](https://raw.githubusercontent.com/hwubh/Temp-Pics/main/20250414143108.png)
- composition: 
  - Ghost: Circles, rings or dots that appear several times and aligned along a line, coming from the sun or a bright source of light.
  - Halo: Bright colors that shift/distort and go around the image.
  - Glare: Also called sunburst or starburst. Shape that appears on the light source itself. It can be a line, or something more complex like a star. It usually depends on the camera aperture/diaphragm.

- methods in video games: 
  - Single sprites: use a billborad or particle system with a bright spot -> simple but the shape is constant.
  - Chained sprites: like the former one, but with several sprites. -> Create directional effect but rarely change in terms of shape and colors.
  - Post-Process:   a shader that reads the scene color and generates a new output from it

- Case Study: 
  - Cyberpunk 2077: like  [John Chapman's article](https://john-chapman-graphics.blogspot.com/2013/02/pseudo-lens-flare.html) , also quite similar to URP.
    - Ghost: Sample source buffer several times
    - Halos: create the ghosts while a radial distortion
    - Blur: reuse bloom downsampled buffer
    - chromatic aberration: 3 samples with a different directional offset
    - Cons: artifacts produced by the UV distortion -> can use  radial mask to hide 
  - Batman Arkham Knight: 
    - Ghost: Sample source buffer several times
    - Halos: a radial distortion effect is applied at their center to make the effect rotate
    - Blur: reuse bloom downsampled buffer
    - chromatic aberration: 3 samples with a different directional offset. However it shifts the red and green component instead of the red and blue
    - Glare: use geometry (Quads)
      - Downsample texture: bloom texture
      - Cloud texture: make noise: add rotation and scale variations based on the screen position
      - 每个顶点（对应2x2像素块）计算平均亮度，如果超过了阈值就生成四边形Quads -> 使用预制的径向渐变纹理定义光源形状
      - Cons: the shape of glare has some kind of flicker at specific angle and velocity.
  - UE4  
    ![20250414154448](https://raw.githubusercontent.com/hwubh/Temp-Pics/main/20250414154448.png)
    - Bloom Generation: No bloom, no lens flare
    - Bloom Compositing: blit bloom
    - Bokeh Blur: The blur itself is generated by drawing an instanced quad for (almost) each pixel. if the luminosity is below the threshold value -> quad size to 0. 
      RT is a quarter of the viewport, ignore too small(<= 2 pixels>) quads.
      actual drawing area is half of the RT
    -  Flare Accumulation: 
       -  A loop draws several time additively into the render target with the copy of the bloom a scaled quad with the bokeh blur pass result (more blur each draw -> the more further, the more blur)
    -  Output
    <!-- -  Overview steps: 
        ![20250414162415](https://raw.githubusercontent.com/hwubh/Temp-Pics/main/20250414162415.png)
       - Threshold: retrive colors from original scene color instead of the bloom downsampled one
       - Ghosts and Halos: Halo is based on John Chapman article.
       - Glare: the glare pass generate a new pattern by drawing custom quads, in a similar vein to the Batman process.
       - Mixing: The previous passes are blended together with the bloom and fed back to the engine to be integrated in the rest of the rendering pipeline (and displayed on screen). -->

- UI 创建： 基于Bloom.cs 创建 ScreenSpaceLensFlare.cs; ScreenSpaceLensFlareEditor； ScreenSpaceLensFlare.shader
  - URPHelpURL: 之后要根据实际的文档调整？？

- Streak: 
  - Prefilter: 
    - 先简单的做个threshold 剔除？ -》 half _Threshold

- Ghost:
  - Wrap中，uv的x决定倒影在极坐标上的X值（角度）， uv的y 决定极坐标的y值（长度）

---------------

- 要转成Linear？
- 亮度需要归一化吗？
- 是否去掉RGBM -> RGBM alpha通道的叠加问题。
- BlendOp -> 
  Adopt "BlendOp Max" to avoid significant changes in intensity when blending colors between RGBM textures, although it is mathematically incorrect.

  The ideal implementation should be：
  1: Create an intermediate RT matching BloomMipUp[0] resolution.
  2: Sample and decode bloom/flare buffers to HDR -> Decode bloom/flare buffers to HDR -> Re-encode composite result to RGBM
  3: Use the intermediate RT as _BloomTexture in uberpost.shader

  However, since RGBM mode targets low-end devices, no sure introducing an additional half-resolution RT and the associated texture sampling operations is acceptable or not.

- 